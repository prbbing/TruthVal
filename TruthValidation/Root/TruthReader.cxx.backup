#include <EventLoop/Job.h>
#include <EventLoop/StatusCode.h>
#include <EventLoop/Worker.h>
#include <TruthValidation/TruthReader.h>

#include "xAODRootAccess/Init.h"
#include "xAODRootAccess/TEvent.h"
#include "xAODRootAccess/tools/Message.h"
#include "xAODEventInfo/EventInfo.h"
#include "xAODTruth/TruthParticleContainer.h"
#include "xAODJet/JetContainer.h"
#include "xAODJet/JetAuxContainer.h"
#include "xAODMissingET/MissingETContainer.h"
#include "TLorentzVector.h"
#include "TruthValidation/Hist.h"

/// Helper macro for checking xAOD::TReturnCode return values
#define EL_RETURN_CHECK( CONTEXT, EXP )			   \
  do {                                                     \
    if( ! EXP.isSuccess() ) {				   \
      Error( CONTEXT,					   \
	     XAOD_MESSAGE( "Failed to execute: %s" ),	   \
	     #EXP );					   \
      return EL::StatusCode::FAILURE;			   \
    }							   \
  } while( false )


// this is needed to distribute the algorithm to the workers
ClassImp(TruthReader)


TruthReader :: TruthReader ()
{
  // Here you put any code for the base initialization of variables,
  // e.g. initialize all pointers to 0.  Note that you should only put
  // the most basic initialization here, since this method will be
  // called on both the submission and the worker node.  Most of your
  // initialization code will go into histInitialize() and
  // initialize().
}



EL::StatusCode TruthReader :: setupJob (EL::Job& job)
{
  // Here you put code that sets up the job on the submission object
  // so that it is ready to work with your algorithm, e.g. you can
  // request the D3PDReader service or add output files.  Any code you
  // put here could instead also go into the submission script.  The
  // sole advantage of putting it here is that it gets automatically
  // activated/deactivated when you add/remove the algorithm from your
  // job, which may or may not be of value to you.

  // let's initialize the algorithm to use the xAODRootAccess package
  job.useXAOD ();
  EL_RETURN_CHECK( "setupJob()", xAOD::Init() ); // call before opening first file

  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: histInitialize ()
{
  // Here you do everything that needs to be done at the very
  // beginning on each worker node, e.g. create histograms and output
  // trees.  This method gets called before any input files are
  // connected.

  // Acceptance

  h_Acceptance   = new TH1F("h_Acceptance", "h_Acceptance", 20, 0, 20);
  h_Acceptance->Sumw2();
  wk()->addOutput (h_Acceptance);
  
  h_Acceptance_b   = new TH1F("h_Acceptance_b", "h_Acceptance_b", 20, 0, 20);
  h_Acceptance_b->Sumw2();
  wk()->addOutput (h_Acceptance_b);
  
  h_mjj   = new TH1D("h_mjj", "h_mjj", 250, 0, 5000);
  h_mjj->Sumw2();
  wk()->addOutput (h_mjj);
  
  h_pt1   = new TH1D("h_pt1", "h_pt1", 125, 0, 2500);
  h_pt1->Sumw2();
  wk()->addOutput (h_pt1);
  
  h_pt2   = new TH1D("h_pt2", "h_pt2", 125, 0, 2500);
  h_pt2->Sumw2();
  wk()->addOutput (h_pt2);
  
  h_pt3   = new TH1D("h_pt3", "h_pt3", 125, 0, 2500);
  h_pt3->Sumw2();
  wk()->addOutput (h_pt3);
  
  h_pt4   = new TH1D("h_pt4", "h_pt4", 125, 0, 2500);
  h_pt4->Sumw2();
  wk()->addOutput (h_pt4);
  
  h_pt5   = new TH1D("h_pt5", "h_pt5", 125, 0, 2500);
  h_pt5->Sumw2();
  wk()->addOutput (h_pt5);
  
  h_eta1   = new TH1D("h_eta1", "h_eta1", 100, -5, 5);
  h_eta1->Sumw2();
  wk()->addOutput (h_eta1);
  
  h_eta2   = new TH1D("h_eta2", "h_eta2", 100, -5, 5);
  h_eta2->Sumw2();
  wk()->addOutput (h_eta2);
  
  h_eta3   = new TH1D("h_eta3", "h_eta3", 100, -5, 5);
  h_eta3->Sumw2();
  wk()->addOutput (h_eta3);
  
  h_eta4   = new TH1D("h_eta4", "h_eta4", 100, -5, 5);
  h_eta4->Sumw2();
  wk()->addOutput (h_eta4);

  h_eta5   = new TH1D("h_eta5", "h_eta5", 100, -5, 5);
  h_eta5->Sumw2();
  wk()->addOutput (h_eta5);
  
  h_phi1   = new TH1D("h_phi1", "h_phi1", 64, -3.2, 3.2);
  h_phi1->Sumw2();
  wk()->addOutput (h_phi1);
  
  h_phi2   = new TH1D("h_phi2", "h_phi2", 64, -3.2, 3.2);
  h_phi2->Sumw2();
  wk()->addOutput (h_phi2);
  
  h_phi3   = new TH1D("h_phi3", "h_phi3", 64, -3.2, 3.2);
  h_phi3->Sumw2();
  wk()->addOutput (h_phi3);
  
  h_phi4   = new TH1D("h_phi4", "h_phi4", 64, -3.2, 3.2);
  h_phi4->Sumw2();
  wk()->addOutput (h_phi4);
  
  h_phi5   = new TH1D("h_phi5", "h_phi5", 64, -3.2, 3.2);
  h_phi5->Sumw2();
  wk()->addOutput (h_phi5);
  
  h_truthId1   = new TH1D("h_truthId1", "h_truthId1", 25, 0, 25);
  h_truthId1->Sumw2();
  wk()->addOutput (h_truthId1);
  
  h_truthId2   = new TH1D("h_truthId2", "h_truthId2", 25, 0, 25);
  h_truthId2->Sumw2();
  wk()->addOutput (h_truthId2);
  
  h_truthId3   = new TH1D("h_truthId3", "h_truthId3", 25, 0, 25);
  h_truthId3->Sumw2();
  wk()->addOutput (h_truthId3);
  
  h_truthId4   = new TH1D("h_truthId4", "h_truthId4", 25, 0, 25);
  h_truthId4->Sumw2();
  wk()->addOutput (h_truthId4);
  
  h_truthId5   = new TH1D("h_truthId5", "h_truthId5", 25, 0, 25);
  h_truthId5->Sumw2();
  wk()->addOutput (h_truthId5);
  
  h_Norm   = new TH1F("h_Norm", "h_Norm;;Norm", 1, 0, 1);
  h_Norm->Sumw2();
  wk()->addOutput (h_Norm);

  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: fileExecute ()
{
  // Here you do everything that needs to be done exactly once for every
  // single file, e.g. collect a list of all lumi-blocks processed
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: changeInput (bool firstFile)
{
  // Here you do everything you need to do when we change input files,
  // e.g. resetting branch addresses on trees.  If you are using
  // D3PDReader or a similar service this method is not needed.
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: initialize ()
{
  // Here you do everything that you need to do after the first input
  // file has been connected and before the first event is processed,
  // e.g. create additional histograms based on which variables are
  // available in the input files.  You can also create all of your
  // histograms and trees in here, but be aware that this method
  // doesn't get called if no events are processed.  So any objects
  // you create here won't be available in the output if you have no
  // input events.

  xAOD::TEvent* event = wk()->xaodEvent();

  // as a check, let's see the number of events in our xAOD
  Info("initialize()", "Number of events = %lli", event->getEntries() ); // print long long int

  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: execute ()
{
  // Here you do everything that needs to be done on every single
  // events, e.g. read input variables, apply cuts, and fill
  // histograms and trees.  This is where most of your actual analysis
  // code will go.

  xAOD::TEvent* event = wk()->xaodEvent();

  //----------------------------
  // Event information
  //--------------------------- 
  const xAOD::EventInfo* eventInfo = 0;
  EL_RETURN_CHECK("execute",event->retrieve( eventInfo, "EventInfo")); 
  // std::cout << eventInfo->eventNumber() << std::endl;

  //----------------------------
  // Jets
  //--------------------------- 
  const xAOD::JetContainer* jets = 0;
  EL_RETURN_CHECK("execute()",event->retrieve( jets, "AntiKt4TruthJets" ));

  std::vector<xAOD::Jet*> v_jet;

  xAOD::JetContainer::const_iterator jet_itr = jets->begin();
  xAOD::JetContainer::const_iterator jet_end = jets->end();
  for( ; jet_itr != jet_end; ++jet_itr ) {
    if(( (*jet_itr)->pt() * 0.001) < 25) continue;
    if( fabs((*jet_itr)->eta()) > 5.0 ) continue;

    xAOD::Jet* jet = new xAOD::Jet();
    jet->makePrivateStore( **jet_itr );
    v_jet.push_back(jet);
  }


  //----------------------------
  // Compute selection variable
  //--------------------------- 
  if ((int)v_jet.size() > 3){
  // Compute Number b-jets
  int N_bjet =0;
  for( int i_jet = 0 ; i_jet < (int)v_jet.size() ; i_jet++ ) {
    if( abs( v_jet.at(i_jet)->auxdata<int>("PartonTruthLabelID") ) == 5 )
      N_bjet++;
  }
  // Compute mjj
  Double_t mcWeight = eventInfo->mcEventWeight();
  h_Acceptance->Fill((float)v_jet.size(),mcWeight);
  if ((int)v_jet.size() >= 1) { 
    h_pt1->Fill(v_jet.at(0)->pt()*0.001,mcWeight);
    h_eta1->Fill(v_jet.at(0)->eta(),mcWeight);
    h_phi1->Fill(v_jet.at(0)->phi(),mcWeight);
    h_truthId1->Fill(abs( v_jet.at(0)->auxdata<int>("PartonTruthLabelID") ),mcWeight);
  }  
  double mjj = 0.0;
  if ((int)v_jet.size() >= 2) { 
    h_pt2->Fill(v_jet.at(1)->pt()*0.001,mcWeight);
    h_eta2->Fill(v_jet.at(1)->eta(),mcWeight);
    h_phi2->Fill(v_jet.at(1)->phi(),mcWeight);
    h_truthId2->Fill(abs( v_jet.at(1)->auxdata<int>("PartonTruthLabelID") ),mcWeight);
    TLorentzVector j_1 = TLorentzVector(v_jet.at(0)->px(), v_jet.at(0)->py(), v_jet.at(0)->pz(), v_jet.at(0)->e());  
    TLorentzVector j_2 = TLorentzVector(v_jet.at(1)->px(), v_jet.at(1)->py(), v_jet.at(1)->pz(), v_jet.at(1)->e()); 
    mjj = (j_1 + j_2).M()*0.001; 
  }  
  if ((int)v_jet.size() >= 3) { 
    h_pt3->Fill(v_jet.at(2)->pt()*0.001,mcWeight);
    h_eta3->Fill(v_jet.at(2)->eta(),mcWeight);
    h_phi3->Fill(v_jet.at(2)->phi(),mcWeight);
    h_truthId3->Fill(abs( v_jet.at(2)->auxdata<int>("PartonTruthLabelID") ),mcWeight);
  }  
  if ((int)v_jet.size() >= 4) { 
    h_pt4->Fill(v_jet.at(3)->pt()*0.001,mcWeight);
    h_eta4->Fill(v_jet.at(3)->eta(),mcWeight);
    h_phi4->Fill(v_jet.at(3)->phi(),mcWeight);
    h_truthId4->Fill(abs( v_jet.at(3)->auxdata<int>("PartonTruthLabelID") ),mcWeight);
  }  
  if ((int)v_jet.size() >= 5) { 
    h_pt5->Fill(v_jet.at(4)->pt()*0.001,mcWeight);
    h_eta5->Fill(v_jet.at(4)->eta(),mcWeight);
    h_phi5->Fill(v_jet.at(4)->phi(),mcWeight);
    h_truthId5->Fill(abs( v_jet.at(4)->auxdata<int>("PartonTruthLabelID") ),mcWeight);
  }  
  //----------------------------
  // Fill Histograms
  //--------------------------- 

  h_Norm->Fill(0.,mcWeight);

  h_mjj->Fill(mjj, mcWeight);
  h_Acceptance_b->Fill((float)N_bjet,mcWeight);
  }
  for( int i = 0 ; i < (int)v_jet.size(); i++)
    delete v_jet[i];
  
  v_jet.clear();

  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: postExecute ()
{
  // Here you do everything that needs to be done after the main event
  // processing.  This is typically very rare, particularly in user
  // code.  It is mainly used in implementing the NTupleSvc.
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: finalize ()
{
  // This method is the mirror image of initialize(), meaning it gets
  // called after the last event has been processed on the worker node
  // and allows you to finish up any objects you created in
  // initialize() before they are written to disk.  This is actually
  // fairly rare, since this happens separately for each worker node.
  // Most of the time you want to do your post-processing on the
  // submission node after all your histogram outputs have been
  // merged.  This is different from histFinalize() in that it only
  // gets called on worker nodes that processed input events.

  xAOD::TEvent* event = wk()->xaodEvent();

  return EL::StatusCode::SUCCESS;
}



EL::StatusCode TruthReader :: histFinalize ()
{
  // This method is the mirror image of histInitialize(), meaning it
  // gets called after the last event has been processed on the worker
  // node and allows you to finish up any objects you created in
  // histInitialize() before they are written to disk.  This is
  // actually fairly rare, since this happens separately for each
  // worker node.  Most of the time you want to do your
  // post-processing on the submission node after all your histogram
  // outputs have been merged.  This is different from finalize() in
  // that it gets called on all worker nodes regardless of whether
  // they processed input events.

  h_Acceptance->Scale( 1./h_Norm->Integral() );
  h_Acceptance_b->Scale( 1./h_Norm->Integral() );
  h_mjj->Scale( 1./h_Norm->Integral() );
  h_pt1->Scale( 1./h_Norm->Integral() );
  h_eta1->Scale( 1./h_Norm->Integral() );
  h_phi1->Scale( 1./h_Norm->Integral() );
  h_truthId1->Scale( 1./h_Norm->Integral() );
  h_pt2->Scale( 1./h_Norm->Integral() );
  h_eta2->Scale( 1./h_Norm->Integral() );
  h_phi2->Scale( 1./h_Norm->Integral() );
  h_truthId2->Scale( 1./h_Norm->Integral() );
  h_pt3->Scale( 1./h_Norm->Integral() );
  h_eta3->Scale( 1./h_Norm->Integral() );
  h_phi3->Scale( 1./h_Norm->Integral() );
  h_truthId3->Scale( 1./h_Norm->Integral() );
  h_pt4->Scale( 1./h_Norm->Integral() );
  h_eta4->Scale( 1./h_Norm->Integral() );
  h_phi4->Scale( 1./h_Norm->Integral() );
  h_truthId4->Scale( 1./h_Norm->Integral() );
  h_pt5->Scale( 1./h_Norm->Integral() );
  h_eta5->Scale( 1./h_Norm->Integral() );
  h_phi5->Scale( 1./h_Norm->Integral() );
  h_truthId5->Scale( 1./h_Norm->Integral() );

  return EL::StatusCode::SUCCESS;
}
